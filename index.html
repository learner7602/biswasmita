<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Urban Highway Racer (Detailed Car)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'primary': '#1f2937', 
                        'secondary': '#facc15', 
                        'road': '#1e272e', 
                        'obstacle': '#10b981', 
                        'car': '#be185d', 
                        'wheel': '#111827', 
                        'barrier': '#2c3e50', 
                        'building': '#1c2833', 
                        'shoulder': '#2f3640', 
                        'tree-trunk': '#8B4513', 
                        'tree-leaves': '#228B22', 
                        'street-light-pole': '#7f8c8d', 
                        'street-light-head': '#f39c12', 
                        'sign-post': '#a0a0a0', 
                        'sign-board': '#34495e', 
                    }
                }
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Custom CSS for the full-screen canvas and body */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111827; 
        }
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10;
        }
        .ui-panel {
            z-index: 20;
            background-color: rgba(31, 41, 55, 0.9);
            backdrop-filter: blur(5px);
            max-width: 90vw;
        }
        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 30;
            display: none;
            place-items: center;
        }
        /* Style for control buttons */
        .control-button {
            border: 2px solid theme('colors.secondary');
            user-select: none;
            -webkit-tap-highlight-color: transparent; 
        }
    </style>
</head>
<body>

    <div id="scene-container"></div>

    <div id="ui-controls" class="ui-panel fixed top-4 right-4 p-3 rounded-xl shadow-2xl border border-secondary/20 text-white flex flex-col items-end gap-2">
        <div class="text-xl font-extrabold text-secondary tracking-wider whitespace-nowrap">
            DISTANCE: <span id="game-score">0</span>m
        </div>
        
        <div class="text-sm text-gray-300 p-1 border border-gray-600 rounded-lg hidden sm:block">
            <span class="font-bold text-secondary">Controls:</span> 
            Steer: <kbd>A</kbd>/<kbd>D</kbd> or <kbd>←</kbd>/<kbd>→</kbd> | 
            Speed: <kbd>W</kbd>/<kbd>S</kbd> or <kbd>↑</kbd>/<kbd>↓</kbd>
        </div>
    </div>

    <div id="touch-controls" class="fixed bottom-0 left-0 right-0 p-6 flex justify-between items-end z-20">
        <div class="flex flex-col gap-4 w-48 sm:w-56">
            <button id="accelerate-button" class="control-button bg-green-600/80 text-white transition duration-150 p-4 rounded-xl shadow-xl h-16 text-base font-black active:bg-green-700/80 border-green-500">
                ACCELERATE (▲)
            </button>
            <button id="brake-button" class="control-button bg-red-600/80 text-white transition duration-150 p-4 rounded-xl shadow-xl h-16 text-base font-black active:bg-red-700/80 border-red-500">
                BRAKE (▼)
            </button>
        </div>
        
        <div class="flex justify-end gap-2 sm:gap-4 w-48 sm:w-56">
            <button id="left-button" class="control-button bg-primary/80 text-secondary transition duration-150 p-4 rounded-xl shadow-xl w-1/2 h-20 text-5xl font-black active:bg-secondary/20">
                &#9664; </button>
            <button id="right-button" class="control-button bg-primary/80 text-secondary transition duration-150 p-4 rounded-xl shadow-xl w-1/2 h-20 text-5xl font-black active:bg-secondary/20">
                &#9654; </button>
        </div>
    </div>

    <div id="game-over-overlay" class="game-over-overlay">
        <div class="bg-primary p-8 rounded-xl shadow-2xl border-4 border-red-500 text-white text-center w-80">
            <h2 class="text-4xl font-black text-red-500 mb-4">CRASHED!</h2>
            <p class="text-lg mb-4">You hit an obstacle.</p>
            <p class="text-2xl font-bold mb-6">Final Distance: <span id="final-score" class="text-secondary">0</span>m</p>
            <button id="restart-button" class="bg-secondary hover:bg-yellow-600 text-primary font-bold py-2 px-6 rounded-full transition duration-150 shadow-lg">
                Try Again
            </button>
        </div>
    </div>

    <script>
        // Global variables for Three.js
        let scene, camera, renderer, container;
        let car, roadMaterial, laneMarkingMaterial, barrierMaterial, buildingMaterial, shoulderMaterial, treeTrunkMaterial, treeLeavesMaterial, streetLightPoleMaterial, streetLightHeadMaterial, signPostMaterial, signBoardMaterial;
        let roadSegments = [];
        let obstacles = [];
        let laneMarkings = []; 
        let roadsideObjects = []; 
        let clock = new THREE.Clock();

        // Game State Variables
        let trackSpeed = 0.5; 
        let targetTrackSpeed = 0.5; 
        const MIN_SPEED = 0.1;
        const MAX_SPEED = 1.2; 
        const ACCEL_RATE = 0.015; 
        const DECEL_RATE = 0.03; 
        let score = 0;
        let isGameOver = false;

        // Player/Car Constants (Used for collision box)
        const CAR_WIDTH = 2;
        const CAR_HEIGHT = 1.5; 
        const CAR_DEPTH = 4.5; 
        const ROAD_WIDTH = 20;
        const ROAD_SEGMENT_LENGTH = 40;
        const MAX_SEGMENTS = 10; 
        
        // Recycling limits
        const Z_DELETE_LIMIT = ROAD_SEGMENT_LENGTH / 2 + 10; 
        const RECYCLE_DISTANCE = ROAD_SEGMENT_LENGTH * MAX_SEGMENTS; 

        const MAX_STEER_X = 7; 
        const STEER_FACTOR = 0.5;
        const MAX_TILT = 0.3; 
        
        // Obstacle Movement Constants
        const OBSTACLE_SWERVE_RANGE = 3; 
        const OBSTACLE_SWERVE_SPEED = 1.5; 
        
        // Lane Marking Constants
        const LANE_MARKING_COLOR = 0xffffff;
        const LANE_MARKING_WIDTH = 0.2;
        const LANE_MARKING_LENGTH = 5;
        const LANE_MARKING_GAP = 5;

        // Environment Constants
        const SHOULDER_WIDTH = 3; 
        const BARRIER_WIDTH = 1;
        const BUILDING_CLUSTER_START_X = (ROAD_WIDTH / 2) + SHOULDER_WIDTH + BARRIER_WIDTH + 5; 
        const BUILDING_MAX_WIDTH = 10;
        const BUILDING_MAX_HEIGHT = 50;

        // Movement Tracking
        let horizontalVelocity = 0; 
        let keys = { 
            A: false, D: false, ArrowLeft: false, ArrowRight: false,
            W: false, ArrowUp: false, 
            S: false, ArrowDown: false 
        };

        // Car Model Template (primitives, not GLTF)
        let playerCarTemplate; 
        let obstacleCarTemplate;
        
        /**
         * Creates a highly detailed, realistic car model using Three.js primitives and PBR materials.
         * @param {number} color - The hexadecimal color for the car's body.
         * @param {boolean} isObstacle - Whether the car is an obstacle (affects lighting/emissive).
         * @returns {THREE.Group} The completed car model group.
         */
        function createDetailedCarModel(color, isObstacle) {
            const carGroup = new THREE.Group();
            
            // --- Materials ---
            const bodyColor = new THREE.Color(color);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: bodyColor,
                metalness: 0.9, // Very metallic
                roughness: 0.4, // Glossy finish
                emissive: isObstacle ? bodyColor.clone().multiplyScalar(0.1) : 0x000000 // Subtle glow for obstacles
            });

            const windowMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x5dade2,
                metalness: 0.1,
                roughness: 0, // Very smooth
                transmission: 0.9, // Highly transparent
                thickness: 0.5,
                opacity: 0.8 // See-through
            });
            
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111827, metalness: 0.5, roughness: 0.8 });
            const rimMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 1.0, roughness: 0.2 });
            const headlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffaa, emissive: 0xffffaa, emissiveIntensity: 3 });
            const taillightMaterial = new THREE.MeshBasicMaterial({ color: 0xcc0000, emissive: 0xcc0000, emissiveIntensity: 2 });

            // --- Geometries ---
            
            // 1. Main Chassis (Lower, longer sports car profile)
            const chassisGeometry = new THREE.BoxGeometry(CAR_WIDTH, 0.8, CAR_DEPTH); 
            const chassis = new THREE.Mesh(chassisGeometry, bodyMaterial);
            chassis.position.y = 0.4;
            carGroup.add(chassis);
            
            // 2. Cabin/Windshield
            const cabinWidth = CAR_WIDTH * 0.9;
            const cabinHeight = CAR_HEIGHT - 0.8;
            const cabinDepth = CAR_DEPTH * 0.6;
            const cabinGeometry = new THREE.BoxGeometry(cabinWidth, cabinHeight, cabinDepth);
            const cabin = new THREE.Mesh(cabinGeometry, bodyMaterial);
            cabin.position.set(0, 0.8 + cabinHeight / 2, -CAR_DEPTH * 0.1); 
            carGroup.add(cabin);

            // 3. Windows (using separate meshes for better glass effect)
            const windowGeom = new THREE.BoxGeometry(cabinWidth * 0.9, cabinHeight * 0.8, cabinDepth * 0.8);
            const windows = new THREE.Mesh(windowGeom, windowMaterial);
            windows.position.copy(cabin.position);
            carGroup.add(windows);
            
            // 4. Wheels (Cylinder for tire, Torus for rim)
            const wheelRadius = 0.4;
            const wheelThickness = 0.3;
            const wheelPositions = [
                { x: CAR_WIDTH / 2, z: CAR_DEPTH * 0.35 },  // Front Right
                { x: -CAR_WIDTH / 2, z: CAR_DEPTH * 0.35 }, // Front Left
                { x: CAR_WIDTH / 2, z: -CAR_DEPTH * 0.35 }, // Back Right
                { x: -CAR_WIDTH / 2, z: -CAR_DEPTH * 0.35 }  // Back Left
            ];

            const tireGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelThickness, 16);
            const rimGeometry = new THREE.TorusGeometry(wheelRadius * 0.8, 0.05, 8, 16);

            wheelPositions.forEach(pos => {
                const tire = new THREE.Mesh(tireGeometry, wheelMaterial);
                tire.rotation.z = Math.PI / 2;
                tire.position.set(pos.x, wheelRadius, pos.z);
                
                const rim = new THREE.Mesh(rimGeometry, rimMaterial);
                rim.rotation.y = Math.PI / 2;
                rim.position.set(0, 0, 0); 
                tire.add(rim);

                carGroup.add(tire);
            });
            
            // 5. Headlights (Front of the chassis)
            const headlight = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.2, 0.1), headlightMaterial);
            headlight.position.set(CAR_WIDTH / 2 - 0.2, 0.7, CAR_DEPTH / 2 - 0.05); 
            carGroup.add(headlight);
            
            const headlight2 = headlight.clone();
            headlight2.position.x *= -1;
            carGroup.add(headlight2);
            
            // 6. Taillights (Back of the chassis)
            const taillight = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.2, 0.1), taillightMaterial);
            taillight.position.set(CAR_WIDTH / 2 - 0.2, 0.7, -CAR_DEPTH / 2 + 0.05);
            taillight.rotation.y = Math.PI; 
            carGroup.add(taillight);
            
            const taillight2 = taillight.clone();
            taillight2.position.x *= -1;
            carGroup.add(taillight2);

            // Set the car's pivot point to the bottom center (Y=0)
            carGroup.position.y = 0; 

            // Ensure all car parts cast a shadow
            carGroup.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                }
            });

            return carGroup;
        }

        /**
         * Creates a single detailed building with varied shapes and window patterns.
         */
        function createDetailedBuilding(width, height, depth) {
            const buildingGroup = new THREE.Group();
            const baseBuildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const baseBuilding = new THREE.Mesh(baseBuildingGeometry, buildingMaterial);
            baseBuilding.position.y = height / 2; 
            buildingGroup.add(baseBuilding);

            const windowColor = new THREE.Color(0x5dade2); 
            const windowMaterial = new THREE.MeshBasicMaterial({ color: windowColor, transparent: true, opacity: 0.8 });

            if (Math.random() < 0.5) { 
                const detailHeight = height * (0.2 + Math.random() * 0.4); 
                const detailWidth = width * (0.6 + Math.random() * 0.3); 
                const detailDepth = depth * (0.2 + Math.random() * 0.3); 

                if (Math.random() < 0.5) { 
                    const setbackGeometry = new THREE.BoxGeometry(detailWidth, detailHeight, detailDepth);
                    const setback = new THREE.Mesh(setbackGeometry, buildingMaterial);
                    setback.position.set(0, height + detailHeight / 2, depth / 2 - detailDepth / 2 - 0.05); 
                    buildingGroup.add(setback);
                } else { 
                    const protrusionGeometry = new THREE.BoxGeometry(detailWidth, detailHeight, detailDepth);
                    const protrusion = new THREE.Mesh(protrusionGeometry, buildingMaterial);
                    protrusion.position.set(0, height * 0.5 + detailHeight / 2, depth / 2 + detailDepth / 2 + 0.05); 
                    buildingGroup.add(protrusion);
                }
            }

            const windowGeometry = new THREE.PlaneGeometry(0.8, 1.2); 
            const numWindowsX = Math.floor(width / 2);
            const numWindowsY = Math.floor(height / 3);

            for (let i = 0; i < numWindowsX; i++) {
                for (let j = 0; j < numWindowsY; j++) {
                    if (Math.random() < 0.7) { 
                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                        windowMesh.position.set(
                            -width / 2 + 1 + i * (width / numWindowsX),
                            1 + j * (height / numWindowsY),
                            depth / 2 + 0.05 
                        );
                        buildingGroup.add(windowMesh);
                    }
                }
            }
            return buildingGroup;
        }

        /**
         * Creates a group of procedural buildings for a segment with more varied detail.
         */
        function createBuildingCluster(segmentZ, side) {
            const cluster = new THREE.Group();
            cluster.position.z = segmentZ;
            cluster.position.y = 0; 

            const startX = BUILDING_CLUSTER_START_X * side;
            let currentX = startX;
            
            while (Math.abs(currentX) < 100) { 
                if (Math.random() < 0.6) { 
                    const width = 8 + Math.random() * BUILDING_MAX_WIDTH;
                    const depth = 8 + Math.random() * 10;
                    const height = 15 + Math.random() * BUILDING_MAX_HEIGHT;

                    const detailedBuilding = createDetailedBuilding(width, height, depth);
                    
                    const x = currentX + (width / 2) * side;
                    
                    detailedBuilding.position.set(x, 0, 0); 
                    detailedBuilding.rotation.y = (Math.random() - 0.5) * 0.1; 
                    
                    cluster.add(detailedBuilding);

                    currentX += (width + 5 + Math.random() * 10) * side;
                } else {
                    currentX += 15 * side; 
                }
            }

            return cluster;
        }

        /**
         * Creates a simple procedural tree model.
         */
        function createTree() {
            const treeGroup = new THREE.Group();
            
            const trunkHeight = 5 + Math.random() * 5;
            const trunkRadius = 0.5 + Math.random() * 0.3;
            const trunkGeometry = new THREE.CylinderGeometry(trunkRadius, trunkRadius * 0.8, trunkHeight, 8);
            const trunk = new THREE.Mesh(trunkGeometry, treeTrunkMaterial);
            trunk.position.y = trunkHeight / 2;
            treeGroup.add(trunk);

            const leavesHeight = 4 + Math.random() * 4;
            const leavesRadius = trunkRadius * 2 + Math.random() * 1;
            const leavesGeometry = new THREE.ConeGeometry(leavesRadius, leavesHeight, 8);
            const leaves = new THREE.Mesh(leavesGeometry, treeLeavesMaterial);
            leaves.position.y = trunkHeight + leavesHeight / 2 - 1; 
            treeGroup.add(leaves);

            return treeGroup;
        }
        
        /**
         * Creates a simple street light model.
         */
        function createStreetLight() {
            const lightGroup = new THREE.Group();

            const poleHeight = 15;
            const poleRadius = 0.2;
            const poleGeometry = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight, 6);
            const pole = new THREE.Mesh(poleGeometry, streetLightPoleMaterial);
            pole.position.y = poleHeight / 2;
            lightGroup.add(pole);

            const armLength = 3;
            const armGeometry = new THREE.BoxGeometry(armLength, 0.2, 0.2);
            const arm = new THREE.Mesh(armGeometry, streetLightPoleMaterial);
            arm.position.set(armLength / 2, poleHeight - 0.5, 0);
            lightGroup.add(arm);

            const headRadius = 0.5;
            const headGeometry = new THREE.SphereGeometry(headRadius, 8, 8);
            const head = new THREE.Mesh(headGeometry, streetLightHeadMaterial);
            head.position.set(armLength, poleHeight - 0.5, 0);
            lightGroup.add(head);

            const lightGlow = new THREE.PointLight(0xfdd835, 1, 15); 
            lightGlow.position.set(armLength, poleHeight - 0.5, 0);
            lightGroup.add(lightGlow);

            return lightGroup;
        }

        /**
         * Creates a simple traffic sign placeholder.
         */
        function createTrafficSign() {
            const signGroup = new THREE.Group();

            const postHeight = 8;
            const postRadius = 0.15;
            const postGeometry = new THREE.CylinderGeometry(postRadius, postRadius, postHeight, 6);
            const post = new THREE.Mesh(postGeometry, signPostMaterial);
            post.position.y = postHeight / 2;
            signGroup.add(post);

            const boardSize = 3;
            const boardGeometry = new THREE.PlaneGeometry(boardSize, boardSize);
            const board = new THREE.Mesh(boardGeometry, signBoardMaterial);
            board.position.set(0, postHeight - boardSize / 2, 0.1); 
            signGroup.add(board);

            return signGroup;
        }


        /**
         * Creates the detailed road side elements (shoulder, barriers, and distant buildings) for a segment.
         */
        function createRoadsideElements(segmentZ) {
            const group = new THREE.Group();
            group.position.z = segmentZ;
            
            const roadEdge = ROAD_WIDTH / 2;

            // 1. Roadside Shoulder/Sidewalk (with subtle texture/color variation)
            const shoulderGeometry = new THREE.PlaneGeometry(SHOULDER_WIDTH, ROAD_SEGMENT_LENGTH);
            const shoulderColor1 = new THREE.Color(0x2f3640);
            const shoulderColor2 = new THREE.Color(0x38414a);
            shoulderMaterial = new THREE.MeshLambertMaterial({ vertexColors: true }); 

            const colors = [];
            const color = new THREE.Color();
            const positions = shoulderGeometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                color.set(Math.random() < 0.5 ? shoulderColor1 : shoulderColor2);
                colors.push(color.r, color.g, color.b);
            }
            shoulderGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));


            const leftShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            leftShoulder.rotation.x = -Math.PI / 2;
            leftShoulder.position.set(-(roadEdge + SHOULDER_WIDTH / 2), 0.005, 0); 
            group.add(leftShoulder);

            const rightShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            rightShoulder.rotation.x = -Math.PI / 2;
            rightShoulder.position.set((roadEdge + SHOULDER_WIDTH / 2), 0.005, 0);
            group.add(rightShoulder);
            
            // 2. Roadside Barriers
            const barrierHeight = 5;
            const barrierDepth = ROAD_SEGMENT_LENGTH;
            const barrierGeometry = new THREE.BoxGeometry(BARRIER_WIDTH, barrierHeight, barrierDepth);
            
            const leftBarrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
            leftBarrier.position.set(-(roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2), barrierHeight / 2, 0);
            group.add(leftBarrier);

            const rightBarrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
            rightBarrier.position.set((roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2), barrierHeight / 2, 0);
            group.add(rightBarrier);

            // 3. Roadside Props (Trees, Street Lights, Signs)
            const propSpawnX = roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH + 1; 
            const propDensity = 0.3; 

            // Trees
            if (Math.random() < propDensity) {
                const tree = createTree();
                tree.position.set(-propSpawnX - (Math.random() * 5 + 2), 0, (Math.random() - 0.5) * ROAD_SEGMENT_LENGTH * 0.8);
                group.add(tree);
            }
            if (Math.random() < propDensity) {
                const tree = createTree();
                tree.position.set(propSpawnX + (Math.random() * 5 + 2), 0, (Math.random() - 0.5) * ROAD_SEGMENT_LENGTH * 0.8);
                group.add(tree);
            }

            // Street Lights (more consistent spacing)
            for (let i = 0; i < 2; i++) { 
                const lightPosOffsetZ = (i === 0 ? -1 : 1) * ROAD_SEGMENT_LENGTH / 4; 
                
                const leftLight = createStreetLight();
                leftLight.position.set(-(roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2 + 1), 0, lightPosOffsetZ);
                group.add(leftLight);

                const rightLight = createStreetLight();
                rightLight.position.set((roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2 + 1), 0, lightPosOffsetZ);
                group.add(rightLight);
            }

            // Traffic Signs
            if (Math.random() < 0.2) { 
                const sign = createTrafficSign();
                sign.position.set(-(roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2 + 1.5), 0, (Math.random() - 0.5) * ROAD_SEGMENT_LENGTH * 0.5);
                group.add(sign);
            }
            if (Math.random() < 0.2) {
                const sign = createTrafficSign();
                sign.position.set((roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2 + 1.5), 0, (Math.random() - 0.5) * ROAD_SEGMENT_LENGTH * 0.5);
                group.add(sign);
            }

            // 4. Distant Buildings (Left and Right Clusters)
            const leftCluster = createBuildingCluster(0, -1);
            const rightCluster = createBuildingCluster(0, 1);
            
            group.add(leftCluster);
            group.add(rightCluster);

            scene.add(group);
            roadsideObjects.push(group);
        }
        
        /**
         * Creates and manages dashed lane markings.
         */
        function createLaneMarkings() {
            if (laneMarkings.length > 0) {
                laneMarkings.forEach(m => scene.remove(m));
                laneMarkings = [];
            }
            
            const dashUnitLength = LANE_MARKING_LENGTH + LANE_MARKING_GAP;
            
            for (let s = 0; s < roadSegments.length; s++) {
                const segmentCenterZ = roadSegments[s].position.z;
                const segmentStartZ = segmentCenterZ - ROAD_SEGMENT_LENGTH / 2; 
                const totalMarkingUnits = Math.floor(ROAD_SEGMENT_LENGTH / dashUnitLength);

                for (let i = 0; i < totalMarkingUnits; i++) {
                    const markingGeometry = new THREE.BoxGeometry(LANE_MARKING_WIDTH, 0.01, LANE_MARKING_LENGTH);
                    const marking = new THREE.Mesh(markingGeometry, laneMarkingMaterial);
                    
                    const zPos = segmentStartZ + (i * dashUnitLength) + (LANE_MARKING_LENGTH / 2);
                    
                    marking.position.set(0, 0.01, zPos); 
                    
                    scene.add(marking);
                    laneMarkings.push(marking);
                }
            }
        }

        /**
         * Initializes the Three.js scene, camera, and renderer.
         */
        function init() {
            
            // 1. Create Model Templates
            if (!playerCarTemplate) {
                playerCarTemplate = createDetailedCarModel(0xbe185d, false); // Player Car: Dark Red Metallic
                obstacleCarTemplate = createDetailedCarModel(0x10b981, true);  // Obstacle Car: Emerald Green Metallic (with subtle emissive)
            }
            
            // Reset game state and speed
            score = 0;
            isGameOver = false;
            trackSpeed = 0.5; 
            targetTrackSpeed = 0.5;
            document.getElementById('game-score').textContent = score;
            document.getElementById('game-over-overlay').style.display = 'none';

            // Clean up existing scene elements if restarting
            if (scene) {
                const objectsToRemove = scene.children.filter(obj => 
                    obj !== camera && 
                    obj.name !== 'directionalLight' && 
                    obj.name !== 'ambientLight' &&
                    obj.name !== 'carSpotLight' &&
                    obj.name !== 'carSpotLightTarget'
                );
                objectsToRemove.forEach(obj => scene.remove(obj));

                roadSegments = [];
                obstacles = [];
                laneMarkings = []; 
                roadsideObjects = []; 
            } else {
                container = document.getElementById('scene-container');
            }

            // 2. Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x111827, 40, 150); 
            scene.background = new THREE.Color(0x111827);

            // 3. Camera Setup
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            // 4. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; // Enable shadows
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            if (container.children.length > 0) {
                container.removeChild(container.children[0]);
            }
            container.appendChild(renderer.domElement);
            
            // 5. Materials (Updated to use MeshStandardMaterial for PBR)
            roadMaterial = new THREE.MeshStandardMaterial({ color: 0x1e272e, roughness: 0.9, metalness: 0.1 }); 
            laneMarkingMaterial = new THREE.MeshBasicMaterial({ color: LANE_MARKING_COLOR }); 
            barrierMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.5, metalness: 0.3 }); 
            buildingMaterial = new THREE.MeshStandardMaterial({ color: 0x1c2833, roughness: 0.7, metalness: 0.1 }); 
            treeTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            treeLeavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.5 });
            streetLightPoleMaterial = new THREE.MeshStandardMaterial({ color: 0x7f8c8d, roughness: 0.6, metalness: 0.7 });
            streetLightHeadMaterial = new THREE.MeshStandardMaterial({ color: 0xf39c12, emissive: 0xf39c12, emissiveIntensity: 0.8 });
            signPostMaterial = new THREE.MeshStandardMaterial({ color: 0xa0a0a0, metalness: 0.9, roughness: 0.2 });
            signBoardMaterial = new THREE.MeshStandardMaterial({ color: 0x34495e, roughness: 0.7 });


            // 6. Lights 
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft ambient light
            ambientLight.name = 'ambientLight';
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
            directionalLight.position.set(0, 20, 10); 
            directionalLight.name = 'directionalLight';
            directionalLight.castShadow = true; 
            directionalLight.shadow.mapSize.width = 2048; 
            directionalLight.shadow.mapSize.height = 2048; 
            directionalLight.shadow.camera.near = 0.5; 
            directionalLight.shadow.camera.far = 50; 
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            scene.add(directionalLight);
            
            // A spot light pointing at the car for better car illumination
            const carSpotLight = new THREE.SpotLight(0xffffff, 5, 100, Math.PI / 8, 0.5);
            carSpotLight.position.set(0, 10, 0);
            carSpotLight.target.position.set(0, 0, -5);
            carSpotLight.name = 'carSpotLight';
            carSpotLight.target.name = 'carSpotLightTarget';
            scene.add(carSpotLight);
            scene.add(carSpotLight.target);


            // 7. Player Car (Cloning the created model)
            car = playerCarTemplate.clone();
            car.position.set(0, 0, 0); 
            scene.add(car);

            // 8. Track Generation
            generateInitialTrack();
            createLaneMarkings();

            // 9. Event Listeners (Unchanged)
            if (!window.listenersAttached) {
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
                document.getElementById('restart-button').addEventListener('click', restartGame);
                
                const leftButton = document.getElementById('left-button');
                const rightButton = document.getElementById('right-button');
                const accelerateButton = document.getElementById('accelerate-button');
                const brakeButton = document.getElementById('brake-button');

                const handleStart = (key) => (event) => {
                    event.preventDefault(); 
                    keys[key] = true;
                };

                const handleEnd = (key) => () => {
                    keys[key] = false;
                };

                leftButton.addEventListener('touchstart', handleStart('ArrowLeft'));
                leftButton.addEventListener('touchend', handleEnd('ArrowLeft'));
                leftButton.addEventListener('mousedown', handleStart('ArrowLeft'));
                leftButton.addEventListener('mouseup', handleEnd('ArrowLeft'));

                rightButton.addEventListener('touchstart', handleStart('ArrowRight'));
                rightButton.addEventListener('touchend', handleEnd('ArrowRight'));
                rightButton.addEventListener('mousedown', handleStart('ArrowRight'));
                rightButton.addEventListener('mouseup', handleEnd('ArrowRight'));

                accelerateButton.addEventListener('touchstart', handleStart('W'));
                accelerateButton.addEventListener('touchend', handleEnd('W'));
                accelerateButton.addEventListener('mousedown', handleStart('W'));
                accelerateButton.addEventListener('mouseup', handleEnd('W'));

                brakeButton.addEventListener('touchstart', handleStart('S'));
                brakeButton.addEventListener('touchend', handleEnd('S'));
                brakeButton.addEventListener('mousedown', handleStart('S'));
                brakeButton.addEventListener('mouseup', handleEnd('S'));
                
                document.getElementById('touch-controls').addEventListener('touchmove', (e) => e.preventDefault());

                window.listenersAttached = true;
            }
            
            clock.start();
            animate(); 
        }

        /**
         * Generates the initial segments of the road, obstacles, and buildings.
         */
        function generateInitialTrack() {
            for (let i = 0; i < MAX_SEGMENTS; i++) {
                const centerZ = -(ROAD_SEGMENT_LENGTH / 2) - i * ROAD_SEGMENT_LENGTH;
                
                let roadMesh;
                if (roadSegments[i]) {
                    roadMesh = roadSegments[i];
                } else {
                    const roadGeometry = new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_SEGMENT_LENGTH);
                    roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
                    roadMesh.receiveShadow = true; 
                    roadSegments.push(roadMesh);
                    scene.add(roadMesh);
                }
                
                roadMesh.rotation.x = -Math.PI / 2;
                roadMesh.position.set(0, 0, centerZ);
                
                createRoadsideElements(centerZ);
                
                if (i < 7 && Math.random() < 0.6) { 
                    spawnObstacle(centerZ);
                }
            }
        }

        /**
         * Spawns a new obstacle car at a given Z position using the cloned template.
         */
        function spawnObstacle(zPosition) {
            const obstacle = obstacleCarTemplate.clone(); 
            const spawnRange = MAX_STEER_X - OBSTACLE_SWERVE_RANGE - (CAR_WIDTH / 2);
            const initialX = (Math.random() - 0.5) * spawnRange * 2;
            
            obstacle.position.set(initialX, 0, zPosition);
            obstacle.rotation.y = Math.PI + (Math.random() - 0.5) * 0.2; 
            
            obstacle.userData.swervePhase = Math.random() * Math.PI * 2; 
            obstacle.userData.initialX = initialX; 
            
            scene.add(obstacle);
            obstacles.push(obstacle);
        }
        
        /**
         * Updates the horizontal position of obstacles to make them swerve.
         */
        function updateObstacleMovement() {
            const time = clock.getElapsedTime(); 

            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                const { swervePhase, initialX } = obstacle.userData;

                const swerveAmount = Math.sin(time * OBSTACLE_SWERVE_SPEED + swervePhase) * OBSTACLE_SWERVE_RANGE;

                let newX = initialX + swerveAmount;
                const maxBoundary = MAX_STEER_X - (CAR_WIDTH / 2); 
                
                newX = Math.max(-maxBoundary, Math.min(newX, maxBoundary));

                obstacle.position.x = newX;
            }
        }

        /**
         * Updates the speed based on W/S or ArrowUp/ArrowDown keys.
         */
        function updateSpeed(delta) {
            if (keys['W'] || keys['ArrowUp']) {
                targetTrackSpeed += ACCEL_RATE * delta * 60; 
            } else if (keys['S'] || keys['ArrowDown']) {
                targetTrackSpeed -= DECEL_RATE * delta * 60; 
            } else {
                if (targetTrackSpeed > MIN_SPEED) {
                    targetTrackSpeed -= 0.005; 
                }
            }

            targetTrackSpeed = Math.max(MIN_SPEED, Math.min(targetTrackSpeed, MAX_SPEED));
            trackSpeed += (targetTrackSpeed - trackSpeed) * 0.05;
            trackSpeed = Math.max(MIN_SPEED, Math.min(trackSpeed, MAX_SPEED));
        }


        /**
         * Updates the position of the road, buildings, and obstacles to simulate forward movement.
         */
        function updateWorldMovement(delta) {
            const moveDistance = trackSpeed * delta * 60; 

            // 1. Move Road Segments and check for recycling
            for (let i = 0; i < roadSegments.length; i++) {
                const segment = roadSegments[i];
                segment.position.z += moveDistance;

                if (segment.position.z > Z_DELETE_LIMIT) {
                    segment.position.z -= RECYCLE_DISTANCE; 
                    if (Math.random() < 0.6) { 
                        spawnObstacle(segment.position.z);
                    }
                }
            }
            
            // 2. Move Roadside Objects 
            for (let i = roadsideObjects.length - 1; i >= 0; i--) {
                const roadsideGroup = roadsideObjects[i];
                roadsideGroup.position.z += moveDistance;

                if (roadsideGroup.position.z > Z_DELETE_LIMIT) {
                    roadsideGroup.position.z -= RECYCLE_DISTANCE;
                    
                    roadsideGroup.children.forEach(child => {
                        if (child.isMesh) {
                            child.geometry.dispose();
                        }
                    });

                    while(roadsideGroup.children.length > 0){
                        roadsideGroup.remove(roadsideGroup.children[0]); 
                    }
                    
                    // Recreate all elements within this recycled segment
                    const recycledZ = roadsideGroup.position.z;
                    
                    const roadEdge = ROAD_WIDTH / 2;

                    // 1. Roadside Shoulder/Sidewalk
                    const shoulderGeometry = new THREE.PlaneGeometry(SHOULDER_WIDTH, ROAD_SEGMENT_LENGTH);
                    const shoulderColor1 = new THREE.Color(0x2f3640);
                    const shoulderColor2 = new THREE.Color(0x38414a);
                    
                    const colors = [];
                    const color = new THREE.Color();
                    const positions = shoulderGeometry.attributes.position.array;
                    for (let j = 0; j < positions.length; j += 3) {
                        color.set(Math.random() < 0.5 ? shoulderColor1 : shoulderColor2);
                        colors.push(color.r, color.g, color.b);
                    }
                    shoulderGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                    const leftShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
                    leftShoulder.rotation.x = -Math.PI / 2;
                    leftShoulder.position.set(-(roadEdge + SHOULDER_WIDTH / 2), 0.005, 0); 
                    roadsideGroup.add(leftShoulder);

                    const rightShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
                    rightShoulder.rotation.x = -Math.PI / 2;
                    rightShoulder.position.set((roadEdge + SHOULDER_WIDTH / 2), 0.005, 0);
                    roadsideGroup.add(rightShoulder);
                    
                    // 2. Roadside Barriers
                    const barrierHeight = 5;
                    const barrierDepth = ROAD_SEGMENT_LENGTH;
                    const barrierGeometry = new THREE.BoxGeometry(BARRIER_WIDTH, barrierHeight, barrierDepth);
                    
                    const leftBarrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
                    leftBarrier.position.set(-(roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2), barrierHeight / 2, 0);
                    roadsideGroup.add(leftBarrier);

                    const rightBarrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
                    rightBarrier.position.set((roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2), barrierHeight / 2, 0);
                    roadsideGroup.add(rightBarrier);

                    // 3. Roadside Props (Trees, Street Lights, Signs)
                    const propSpawnX = roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH + 1; 
                    const propDensity = 0.3; 

                    if (Math.random() < propDensity) {
                        const tree = createTree();
                        tree.position.set(-propSpawnX - (Math.random() * 5 + 2), 0, (Math.random() - 0.5) * ROAD_SEGMENT_LENGTH * 0.8);
                        roadsideGroup.add(tree);
                    }
                    if (Math.random() < propDensity) {
                        const tree = createTree();
                        tree.position.set(propSpawnX + (Math.random() * 5 + 2), 0, (Math.random() - 0.5) * ROAD_SEGMENT_LENGTH * 0.8);
                        roadsideGroup.add(tree);
                    }
                    
                    for (let j = 0; j < 2; j++) {
                        const lightPosOffsetZ = (j === 0 ? -1 : 1) * ROAD_SEGMENT_LENGTH / 4; 
                        
                        const leftLight = createStreetLight();
                        leftLight.position.set(-(roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2 + 1), 0, lightPosOffsetZ);
                        roadsideGroup.add(leftLight);

                        const rightLight = createStreetLight();
                        rightLight.position.set((roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2 + 1), 0, lightPosOffsetZ);
                        roadsideGroup.add(rightLight);
                    }

                    if (Math.random() < 0.2) { 
                        const sign = createTrafficSign();
                        sign.position.set(-(roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2 + 1.5), 0, (Math.random() - 0.5) * ROAD_SEGMENT_LENGTH * 0.5);
                        roadsideGroup.add(sign);
                    }
                    if (Math.random() < 0.2) {
                        const sign = createTrafficSign();
                        sign.position.set((roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2 + 1.5), 0, (Math.random() - 0.5) * ROAD_SEGMENT_LENGTH * 0.5);
                        roadsideGroup.add(sign);
                    }

                    // 4. Distant Buildings (Left and Right Clusters)
                    const newLeftCluster = createBuildingCluster(0, -1);
                    const newRightCluster = createBuildingCluster(0, 1);
                    roadsideGroup.add(newLeftCluster);
                    roadsideGroup.add(newRightCluster);
                }
            }
            
            // 3. Move Lane Markings
            for (let i = 0; i < laneMarkings.length; i++) {
                const marking = laneMarkings[i];
                marking.position.z += moveDistance;

                if (marking.position.z > Z_DELETE_LIMIT) {
                    marking.position.z -= RECYCLE_DISTANCE; 
                }
            }

            // 4. Move Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position.z += moveDistance;

                if (obstacle.position.z > Z_DELETE_LIMIT) {
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                }
            }
        }

        /**
         * Checks for collision between the car and any obstacles.
         */
        function checkCollisions() {
            const carCollisionBox = new THREE.Box3().setFromCenterAndSize(
                car.position,
                new THREE.Vector3(CAR_WIDTH, CAR_HEIGHT, CAR_DEPTH)
            );
            
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                const obstacleBox = new THREE.Box3().setFromCenterAndSize(
                    obstacle.position,
                    new THREE.Vector3(CAR_WIDTH, CAR_HEIGHT, CAR_DEPTH)
                );

                if (carCollisionBox.intersectsBox(obstacleBox)) {
                    endGame();
                    break;
                }
            }
        }
        
        /**
         * Handles the Game Over state.
         */
        function endGame() {
            isGameOver = true;
            document.getElementById('final-score').textContent = Math.floor(score * 10);
            document.getElementById('game-over-overlay').style.display = 'grid';
            clock.stop();
        }
        
        /**
         * Restarts the game.
         */
        function restartGame() {
            init(); 
        }

        /**
         * Handles the window resize event.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Handles key down events for steering and speed.
         */
        function onKeyDown(event) {
            const key = event.key;
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
                event.preventDefault(); 
            }
        }

        /**
         * Handles key up events for steering and speed.
         */
        function onKeyUp(event) {
            const key = event.key;
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
        }
        
        /**
         * Updates the car's horizontal position and rotation based on key input.
         */
        function updateCarSteering(delta) {
            horizontalVelocity = 0;
            if (keys['A'] || keys['ArrowLeft']) {
                horizontalVelocity = -1;
            } else if (keys['D'] || keys['ArrowRight']) {
                horizontalVelocity = 1;
            }

            if (horizontalVelocity !== 0) {
                const steerMultiplier = 0.5 + (trackSpeed / MAX_SPEED) * 0.5; 
                car.position.x += horizontalVelocity * STEER_FACTOR * steerMultiplier * delta * 60;
                
                car.position.x = Math.max(-MAX_STEER_X, Math.min(car.position.x, MAX_STEER_X));
            }
            
            // Apply rotation to the visual model
            const targetTilt = horizontalVelocity * -MAX_TILT; 
            car.rotation.z += (targetTilt - car.rotation.z) * 0.1;

            camera.position.x = car.position.x;
        }

        /**
         * The main animation loop.
         */
        function animate() {
            if (isGameOver) {
                renderer.render(scene, camera);
                return; 
            }

            requestAnimationFrame(animate);

            const delta = clock.getDelta(); 

            // 1. Update Player Input/Movement
            updateCarSteering(delta);
            updateSpeed(delta); 

            // 2. Update Game State
            score += trackSpeed * delta; 
            document.getElementById('game-score').textContent = Math.floor(score * 10); 

            // 3. Dynamic Obstacle Movement 
            updateObstacleMovement();

            // 4. World Movement (Road, Buildings, etc.)
            updateWorldMovement(delta);

            // 5. Check for Collisions
            checkCollisions();

            // 6. Render the Scene
            renderer.render(scene, camera);
        }

        // Start the application
        window.onload = function () {
            init();
        };

    </script>
</body>
</html>
