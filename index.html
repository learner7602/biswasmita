<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Urban Highway Racer (Detailed Environment)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'primary': '#1f2937', 
                        'secondary': '#facc15', 
                        'road': '#1e272e', 
                        'obstacle': '#10b981', 
                        'car': '#be185d', 
                        'wheel': '#111827', 
                        'barrier': '#2c3e50', 
                        'building': '#1c2833', 
                        'shoulder': '#2f3640', // New: Darker concrete/gravel look
                    }
                }
            }
        }
    </script>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* Custom CSS for the full-screen canvas and body */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111827; 
        }
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10;
        }
        .ui-panel {
            z-index: 20;
            background-color: rgba(31, 41, 55, 0.9);
            backdrop-filter: blur(5px);
            max-width: 90vw;
        }
        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 30;
            display: none;
            place-items: center;
        }
        /* Style for control buttons */
        .control-button {
            border: 2px solid theme('colors.secondary');
            user-select: none;
            -webkit-tap-highlight-color: transparent; 
        }
    </style>
</head>
<body>

    <!-- Three.js Scene Container -->
    <div id="scene-container"></div>

    <!-- UI Score and Controls Panel (Top-Right) -->
    <div id="ui-controls" class="ui-panel fixed top-4 right-4 p-3 rounded-xl shadow-2xl border border-secondary/20 text-white flex flex-col items-end gap-2">
        <div class="text-xl font-extrabold text-secondary tracking-wider whitespace-nowrap">
            DISTANCE: <span id="game-score">0</span>m
        </div>
        
        <!-- Instructions (Updated for speed control) -->
        <div class="text-sm text-gray-300 p-1 border border-gray-600 rounded-lg hidden sm:block">
            <span class="font-bold text-secondary">Controls:</span> 
            Steer: <kbd>A</kbd>/<kbd>D</kbd> or <kbd>←</kbd>/<kbd>→</kbd> | 
            Speed: <kbd>W</kbd>/<kbd>S</kbd> or <kbd>↑</kbd>/<kbd>↓</kbd>
        </div>
    </div>

    <!-- Touch Controls for Mobile Users (Bottom) -->
    <div id="touch-controls" class="fixed bottom-0 left-0 right-0 p-4 flex flex-col items-center sm:hidden z-20">
        <!-- Speed Controls (Top Row of Mobile Controls) -->
        <div class="flex justify-center gap-4 mb-4 w-full max-w-sm">
            <button id="accelerate-button" class="control-button bg-green-600/80 text-white transition duration-150 p-3 rounded-xl shadow-xl w-32 h-12 text-sm font-black active:bg-green-700/80 border-green-500">
                ACCELERATE (▲)
            </button>
            <button id="brake-button" class="control-button bg-red-600/80 text-white transition duration-150 p-3 rounded-xl shadow-xl w-32 h-12 text-sm font-black active:bg-red-700/80 border-red-500">
                BRAKE (▼)
            </button>
        </div>
        <!-- Steering Controls (Bottom Row of Mobile Controls) -->
        <div class="flex justify-between w-full max-w-sm">
            <button id="left-button" class="control-button bg-primary/80 text-secondary transition duration-150 p-4 rounded-xl shadow-xl w-32 h-16 text-4xl font-black active:bg-secondary/20">
                &#9664; <!-- Left Arrow -->
            </button>
            <button id="right-button" class="control-button bg-primary/80 text-secondary transition duration-150 p-4 rounded-xl shadow-xl w-32 h-16 text-4xl font-black active:bg-secondary/20">
                &#9654; <!-- Right Arrow -->
            </button>
        </div>
    </div>

    <!-- Game Over Message Box -->
    <div id="game-over-overlay" class="game-over-overlay">
        <div class="bg-primary p-8 rounded-xl shadow-2xl border-4 border-red-500 text-white text-center w-80">
            <h2 class="text-4xl font-black text-red-500 mb-4">CRASHED!</h2>
            <p class="text-lg mb-4">You hit an obstacle.</p>
            <p class="text-2xl font-bold mb-6">Final Distance: <span id="final-score" class="text-secondary">0</span>m</p>
            <button id="restart-button" class="bg-secondary hover:bg-yellow-600 text-primary font-bold py-2 px-6 rounded-full transition duration-150 shadow-lg">
                Try Again
            </button>
        </div>
    </div>

    <script>
        // Global variables for Three.js
        let scene, camera, renderer, container;
        let car, roadMaterial, laneMarkingMaterial, barrierMaterial, buildingMaterial, shoulderMaterial;
        let roadSegments = [];
        let obstacles = [];
        let laneMarkings = []; 
        let roadsideObjects = []; // Stores the building/barrier groups
        let clock = new THREE.Clock();

        // Game State Variables
        let trackSpeed = 0.5; // Current speed, changes dynamically
        let targetTrackSpeed = 0.5; // Speed the car is aiming for
        const MIN_SPEED = 0.1;
        const MAX_SPEED = 1.2; 
        const ACCEL_RATE = 0.015; 
        const DECEL_RATE = 0.03; 
        let score = 0;
        let isGameOver = false;

        // Player/Car Constants
        const CAR_WIDTH = 2;
        const CAR_HEIGHT = 1;
        const CAR_DEPTH = 3;
        const ROAD_WIDTH = 20;
        const ROAD_SEGMENT_LENGTH = 40;
        const MAX_SEGMENTS = 10; 
        
        // Recycling limits
        const Z_DELETE_LIMIT = ROAD_SEGMENT_LENGTH / 2 + 10; 
        const RECYCLE_DISTANCE = ROAD_SEGMENT_LENGTH * MAX_SEGMENTS; 

        const MAX_STEER_X = 7; 
        const STEER_FACTOR = 0.5;
        const MAX_TILT = 0.3; 
        
        // Obstacle Movement Constants
        const OBSTACLE_SWERVE_RANGE = 3; 
        const OBSTACLE_SWERVE_SPEED = 1.5; 
        
        // Lane Marking Constants
        const LANE_MARKING_COLOR = 0xffffff;
        const LANE_MARKING_WIDTH = 0.2;
        const LANE_MARKING_LENGTH = 5;
        const LANE_MARKING_GAP = 5;

        // Environment Constants (NEW & UPDATED)
        const SHOULDER_WIDTH = 3; 
        const BARRIER_WIDTH = 1;
        // Buildings start outside the road, shoulder, and barrier, plus a gap
        const BUILDING_CLUSTER_START_X = (ROAD_WIDTH / 2) + SHOULDER_WIDTH + BARRIER_WIDTH + 5; 
        const BUILDING_MAX_WIDTH = 10;
        const BUILDING_MAX_HEIGHT = 50;

        // Movement Tracking
        let horizontalVelocity = 0; 
        let keys = { 
            A: false, D: false, ArrowLeft: false, ArrowRight: false,
            W: false, ArrowUp: false, 
            S: false, ArrowDown: false 
        };

        /**
         * Creates a detailed player car model.
         */
        function createCarModel() {
            const carGroup = new THREE.Group();
            const carMaterial = new THREE.MeshLambertMaterial({ color: 0xbe185d }); 
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x111827 }); 

            // Chassis
            const chassisGeometry = new THREE.BoxGeometry(CAR_WIDTH, 0.7, CAR_DEPTH);
            const chassis = new THREE.Mesh(chassisGeometry, carMaterial);
            chassis.position.y = 0.35; 
            
            // Cabin
            const cabinGeometry = new THREE.BoxGeometry(CAR_WIDTH * 0.7, 0.6, CAR_DEPTH * 0.4);
            const cabin = new THREE.Mesh(cabinGeometry, carMaterial);
            cabin.position.y = chassis.position.y + 0.3 + 0.3; 
            cabin.position.z = -0.3; 
            
            carGroup.add(chassis);
            carGroup.add(cabin);

            // Wheels
            const wheelRadius = 0.5;
            const wheelThickness = 0.3;
            const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelThickness, 8);
            
            const createWheel = (x, z) => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2; 
                wheel.position.set(x, wheelRadius, z);
                return wheel;
            };

            const wheelXOffset = CAR_WIDTH / 2 + 0.1;
            const wheelZOffset = CAR_DEPTH / 2 - 0.5;

            carGroup.add(createWheel(-wheelXOffset, wheelZOffset));
            carGroup.add(createWheel(wheelXOffset, wheelZOffset));
            carGroup.add(createWheel(-wheelXOffset, -wheelZOffset));
            carGroup.add(createWheel(wheelXOffset, -wheelZOffset));
            
            carGroup.position.set(0, CAR_HEIGHT / 2, 0);

            return carGroup;
        }

        /**
         * Creates a car model for obstacles (Green body, Black wheels).
         */
        function createObstacleCarModel() {
            const carGroup = new THREE.Group();
            
            const obstacleCarColor = new THREE.Color(0x10b981); 
            const obstacleCarMaterial = new THREE.MeshLambertMaterial({ color: obstacleCarColor });
            const obstacleWheelMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 }); 

            // Chassis
            const chassisGeometry = new THREE.BoxGeometry(CAR_WIDTH, 0.7, CAR_DEPTH);
            const chassis = new THREE.Mesh(chassisGeometry, obstacleCarMaterial);
            chassis.position.y = 0.35; 
            
            // Cabin/Roof
            const cabinGeometry = new THREE.BoxGeometry(CAR_WIDTH * 0.7, 0.6, CAR_DEPTH * 0.4);
            const cabin = new THREE.Mesh(cabinGeometry, obstacleCarMaterial);
            cabin.position.y = chassis.position.y + 0.3 + 0.3;
            cabin.position.z = -0.3;
            
            carGroup.add(chassis);
            carGroup.add(cabin);

            // Wheels
            const wheelRadius = 0.5;
            const wheelThickness = 0.3;
            const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelThickness, 8);
            
            const createWheel = (x, z) => {
                const wheel = new THREE.Mesh(wheelGeometry, obstacleWheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(x, wheelRadius, z);
                return wheel;
            };

            const wheelXOffset = CAR_WIDTH / 2 + 0.1;
            const wheelZOffset = CAR_DEPTH / 2 - 0.5;

            carGroup.add(createWheel(-wheelXOffset, wheelZOffset));
            carGroup.add(createWheel(wheelXOffset, wheelZOffset));
            carGroup.add(createWheel(-wheelXOffset, -wheelZOffset));
            carGroup.add(createWheel(wheelXOffset, -wheelZOffset));
            
            carGroup.position.set(0, 0, 0);

            return carGroup;
        }
        
        /**
         * Creates a group of procedural buildings for a segment with window detail.
         * @param {number} segmentZ The Z coordinate to align the buildings with.
         * @param {number} side -1 for left side, 1 for right side.
         * @returns {THREE.Group} Group of building meshes.
         */
        function createBuildingCluster(segmentZ, side) {
            const cluster = new THREE.Group();
            cluster.position.z = segmentZ;
            cluster.position.y = 0; 

            const startX = BUILDING_CLUSTER_START_X * side;
            let currentX = startX;
            
            // Material for simulating lit windows
            const windowColor = new THREE.Color(0x5dade2); 
            const windowMaterial = new THREE.MeshBasicMaterial({ color: windowColor, transparent: true, opacity: 0.8 });

            while (Math.abs(currentX) < 80) { // Extend range for a larger city feel
                if (Math.random() < 0.6) { // 60% chance to place a building
                    const width = 8 + Math.random() * BUILDING_MAX_WIDTH;
                    const depth = 8 + Math.random() * 10;
                    const height = 15 + Math.random() * BUILDING_MAX_HEIGHT;

                    const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    
                    // Position X relative to the center of the road
                    const x = currentX + (width / 2) * side;
                    
                    // Apply scale variation and set position
                    building.scale.y = 0.8 + Math.random() * 0.4; // 80% to 120% height
                    building.position.set(x, (height * building.scale.y) / 2, 0);

                    // Slightly rotate the cluster for perspective
                    building.rotation.y = (Math.random() - 0.5) * 0.1;
                    
                    cluster.add(building);

                    // --- Procedural Window Stripes (Realism) ---
                    const stripeWidth = 0.5;
                    const stripeGap = 5;

                    // Vertical Stripes (on the front face)
                    for (let i = -width/2 + stripeGap/2; i < width/2; i += stripeGap) {
                        if (Math.random() < 0.7) { 
                            const vStripeFront = new THREE.Mesh(new THREE.PlaneGeometry(stripeWidth, height * building.scale.y), windowMaterial);
                            // Position in front of the building face by a tiny amount
                            vStripeFront.position.set(i + building.position.x, building.position.y, building.position.z + depth / 2 + 0.05);
                            cluster.add(vStripeFront);
                        }
                    }

                    // Horizontal Stripes (on the front face)
                    const hStripeHeight = 0.5;
                    for (let i = 5; i < height * building.scale.y - 5; i += stripeGap) {
                        if (Math.random() < 0.4) { 
                            const hStripeFront = new THREE.Mesh(new THREE.PlaneGeometry(width, hStripeHeight), windowMaterial);
                            hStripeFront.position.set(building.position.x, i, building.position.z + depth / 2 + 0.05);
                            cluster.add(hStripeFront);
                        }
                    }
                    // --- End Window Stripes ---


                    // Move to the next potential placement spot
                    currentX += (width + 5 + Math.random() * 10) * side;
                } else {
                    // Add a larger gap
                    currentX += 15 * side;
                }
            }

            return cluster;
        }

        /**
         * Creates the detailed road side elements (shoulder, barriers, and distant buildings) for a segment.
         */
        function createRoadsideElements(segmentZ) {
            const group = new THREE.Group();
            group.position.z = segmentZ;
            
            const roadEdge = ROAD_WIDTH / 2;

            // 1. Roadside Shoulder/Sidewalk (NEW)
            const shoulderGeometry = new THREE.PlaneGeometry(SHOULDER_WIDTH, ROAD_SEGMENT_LENGTH);
            
            // Left Shoulder
            const leftShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            leftShoulder.rotation.x = -Math.PI / 2;
            // Positioned outside the road edge
            leftShoulder.position.set(-(roadEdge + SHOULDER_WIDTH / 2), 0.005, 0); 
            group.add(leftShoulder);

            // Right Shoulder
            const rightShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            rightShoulder.rotation.x = -Math.PI / 2;
            rightShoulder.position.set((roadEdge + SHOULDER_WIDTH / 2), 0.005, 0);
            group.add(rightShoulder);
            
            // 2. Roadside Barriers
            const barrierHeight = 5;
            const barrierDepth = ROAD_SEGMENT_LENGTH;
            const barrierGeometry = new THREE.BoxGeometry(BARRIER_WIDTH, barrierHeight, barrierDepth);
            
            // Left Barrier
            const leftBarrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
            // Positioned just outside the shoulder
            leftBarrier.position.set(-(roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2), barrierHeight / 2, 0);
            group.add(leftBarrier);

            // Right Barrier
            const rightBarrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
            rightBarrier.position.set((roadEdge + SHOULDER_WIDTH + BARRIER_WIDTH / 2), barrierHeight / 2, 0);
            group.add(rightBarrier);

            // 3. Distant Buildings (Left and Right Clusters)
            const leftCluster = createBuildingCluster(0, -1);
            const rightCluster = createBuildingCluster(0, 1);
            
            group.add(leftCluster);
            group.add(rightCluster);

            scene.add(group);
            roadsideObjects.push(group);
        }
        
        /**
         * Creates and manages dashed lane markings.
         */
        function createLaneMarkings() {
            if (laneMarkings.length > 0) {
                laneMarkings.forEach(m => scene.remove(m));
                laneMarkings = [];
            }
            
            const dashUnitLength = LANE_MARKING_LENGTH + LANE_MARKING_GAP;
            
            for (let s = 0; s < roadSegments.length; s++) {
                const segmentCenterZ = roadSegments[s].position.z;
                const segmentStartZ = segmentCenterZ - ROAD_SEGMENT_LENGTH / 2; 
                const totalMarkingUnits = Math.floor(ROAD_SEGMENT_LENGTH / dashUnitLength);

                for (let i = 0; i < totalMarkingUnits; i++) {
                    const markingGeometry = new THREE.BoxGeometry(LANE_MARKING_WIDTH, 0.01, LANE_MARKING_LENGTH);
                    const marking = new THREE.Mesh(markingGeometry, laneMarkingMaterial);
                    
                    const zPos = segmentStartZ + (i * dashUnitLength) + (LANE_MARKING_LENGTH / 2);
                    
                    marking.position.set(0, 0.01, zPos); 
                    
                    scene.add(marking);
                    laneMarkings.push(marking);
                }
            }
        }

        /**
         * Initializes the Three.js scene, camera, and renderer.
         */
        function init() {
            // Reset game state and speed
            score = 0;
            isGameOver = false;
            trackSpeed = 0.5; 
            targetTrackSpeed = 0.5;
            document.getElementById('game-score').textContent = score;
            document.getElementById('game-over-overlay').style.display = 'none';

            // Clean up existing scene elements if restarting
            if (scene) {
                scene.children.forEach(child => scene.remove(child));
                roadSegments = [];
                obstacles = [];
                laneMarkings = []; 
                roadsideObjects = []; 
            } else {
                container = document.getElementById('scene-container');
            }

            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x111827, 40, 150); 
            scene.background = new THREE.Color(0x111827);

            // 2. Camera Setup
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            if (container.children.length > 0) {
                container.removeChild(container.children[0]);
            }
            container.appendChild(renderer.domElement);
            
            // 4. Materials 
            roadMaterial = new THREE.MeshLambertMaterial({ color: 0x1e272e }); 
            laneMarkingMaterial = new THREE.MeshBasicMaterial({ color: LANE_MARKING_COLOR }); 
            barrierMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e50 }); 
            buildingMaterial = new THREE.MeshLambertMaterial({ color: 0x1c2833 }); 
            shoulderMaterial = new THREE.MeshLambertMaterial({ color: 0x2f3640 }); // Defined new shoulder material

            // 5. Lights 
            const ambientLight = new THREE.AmbientLight(0x404040, 3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 5);
            directionalLight.position.set(0, 10, 10); 
            scene.add(directionalLight);

            // 6. Player Car
            car = createCarModel();
            car.position.set(0, 0, 0); 
            scene.add(car);

            // 7. Track Generation
            generateInitialTrack();
            createLaneMarkings();

            // 8. Event Listeners (Unchanged, remains for controls)
            if (!window.listenersAttached) {
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
                document.getElementById('restart-button').addEventListener('click', restartGame);
                
                const leftButton = document.getElementById('left-button');
                const rightButton = document.getElementById('right-button');
                const accelerateButton = document.getElementById('accelerate-button');
                const brakeButton = document.getElementById('brake-button');

                const handleStart = (key) => (event) => {
                    event.preventDefault(); 
                    keys[key] = true;
                };

                const handleEnd = (key) => () => {
                    keys[key] = false;
                };

                leftButton.addEventListener('touchstart', handleStart('ArrowLeft'));
                leftButton.addEventListener('touchend', handleEnd('ArrowLeft'));
                leftButton.addEventListener('mousedown', handleStart('ArrowLeft'));
                leftButton.addEventListener('mouseup', handleEnd('ArrowLeft'));

                rightButton.addEventListener('touchstart', handleStart('ArrowRight'));
                rightButton.addEventListener('touchend', handleEnd('ArrowRight'));
                rightButton.addEventListener('mousedown', handleStart('ArrowRight'));
                rightButton.addEventListener('mouseup', handleEnd('ArrowRight'));

                accelerateButton.addEventListener('touchstart', handleStart('W'));
                accelerateButton.addEventListener('touchend', handleEnd('W'));
                accelerateButton.addEventListener('mousedown', handleStart('W'));
                accelerateButton.addEventListener('mouseup', handleEnd('W'));

                brakeButton.addEventListener('touchstart', handleStart('S'));
                brakeButton.addEventListener('touchend', handleEnd('S'));
                brakeButton.addEventListener('mousedown', handleStart('S'));
                brakeButton.addEventListener('mouseup', handleEnd('S'));
                
                document.getElementById('touch-controls').addEventListener('touchmove', (e) => e.preventDefault());

                window.listenersAttached = true;
            }
            
            clock.start();
        }

        /**
         * Generates the initial segments of the road, obstacles, and buildings.
         */
        function generateInitialTrack() {
            for (let i = 0; i < MAX_SEGMENTS; i++) {
                const centerZ = -(ROAD_SEGMENT_LENGTH / 2) - i * ROAD_SEGMENT_LENGTH;
                
                // Road Segment (Recycling logic ensures we don't recreate meshes unnecessarily)
                let roadMesh;
                if (roadSegments[i]) {
                    roadMesh = roadSegments[i];
                } else {
                    const roadGeometry = new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_SEGMENT_LENGTH);
                    roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
                    roadSegments.push(roadMesh);
                    scene.add(roadMesh);
                }
                
                roadMesh.rotation.x = -Math.PI / 2;
                roadMesh.position.set(0, 0, centerZ);
                
                // Roadside Elements (Shoulder, Barriers, Buildings)
                createRoadsideElements(centerZ);
                
                // Obstacle Spawn
                if (i < 7 && Math.random() < 0.6) { 
                    spawnObstacle(centerZ);
                }
            }
        }

        /**
         * Spawns a new obstacle car at a given Z position.
         */
        function spawnObstacle(zPosition) {
            const obstacle = createObstacleCarModel(); 
            const spawnRange = MAX_STEER_X - OBSTACLE_SWERVE_RANGE - (CAR_WIDTH / 2);
            const initialX = (Math.random() - 0.5) * spawnRange * 2;
            
            obstacle.position.set(initialX, 0, zPosition);
            obstacle.rotation.y = (Math.random() - 0.5) * 0.2; 
            
            obstacle.userData.swervePhase = Math.random() * Math.PI * 2; 
            obstacle.userData.initialX = initialX; 
            
            scene.add(obstacle);
            obstacles.push(obstacle);
        }
        
        /**
         * Updates the horizontal position of obstacles to make them swerve.
         */
        function updateObstacleMovement() {
            const time = clock.getElapsedTime(); 

            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                const { swervePhase, initialX } = obstacle.userData;

                const swerveAmount = Math.sin(time * OBSTACLE_SWERVE_SPEED + swervePhase) * OBSTACLE_SWERVE_RANGE;

                let newX = initialX + swerveAmount;
                const maxBoundary = MAX_STEER_X - (CAR_WIDTH / 2); 
                
                newX = Math.max(-maxBoundary, Math.min(newX, maxBoundary));

                obstacle.position.x = newX;
            }
        }

        /**
         * Updates the speed based on W/S or ArrowUp/ArrowDown keys.
         */
        function updateSpeed(delta) {
            if (keys['W'] || keys['ArrowUp']) {
                targetTrackSpeed += ACCEL_RATE * delta * 60; 
            } else if (keys['S'] || keys['ArrowDown']) {
                targetTrackSpeed -= DECEL_RATE * delta * 60; 
            } else {
                if (targetTrackSpeed > MIN_SPEED) {
                    targetTrackSpeed -= 0.005; 
                }
            }

            targetTrackSpeed = Math.max(MIN_SPEED, Math.min(targetTrackSpeed, MAX_SPEED));
            trackSpeed += (targetTrackSpeed - trackSpeed) * 0.05;
            trackSpeed = Math.max(MIN_SPEED, Math.min(trackSpeed, MAX_SPEED));
        }


        /**
         * Updates the position of the road, buildings, and obstacles to simulate forward movement.
         */
        function updateWorldMovement(delta) {
            const moveDistance = trackSpeed * delta * 60; 

            // 1. Move Road Segments and check for recycling
            for (let i = 0; i < roadSegments.length; i++) {
                const segment = roadSegments[i];
                segment.position.z += moveDistance;

                if (segment.position.z > Z_DELETE_LIMIT) {
                    segment.position.z -= RECYCLE_DISTANCE; 
                    if (Math.random() < 0.6) { 
                        spawnObstacle(segment.position.z);
                    }
                }
            }
            
            // 2. Move Roadside Objects (Shoulders, Barriers, and Buildings)
            for (let i = roadsideObjects.length - 1; i >= 0; i--) {
                const roadsideGroup = roadsideObjects[i];
                roadsideGroup.position.z += moveDistance;

                if (roadsideGroup.position.z > Z_DELETE_LIMIT) {
                    // Recycle roadside group position
                    roadsideGroup.position.z -= RECYCLE_DISTANCE;
                    
                    // Clear and regenerate the building clusters to create a new environment look
                    // Find the two THREE.Groups that contain the buildings and remove them
                    const oldClusters = roadsideGroup.children.filter(c => c.type === 'Group');
                    
                    oldClusters.forEach(cluster => {
                        roadsideGroup.remove(cluster);
                        cluster.children.forEach(child => child.geometry.dispose()); // Clean up geometry
                    });

                    // Regenerate new building clusters
                    const newLeft = createBuildingCluster(0, -1);
                    const newRight = createBuildingCluster(0, 1);
                    roadsideGroup.add(newLeft);
                    roadsideGroup.add(newRight);
                }
            }
            
            // 3. Move Lane Markings
            for (let i = 0; i < laneMarkings.length; i++) {
                const marking = laneMarkings[i];
                marking.position.z += moveDistance;

                if (marking.position.z > Z_DELETE_LIMIT) {
                    marking.position.z -= RECYCLE_DISTANCE; 
                }
            }

            // 4. Move Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position.z += moveDistance;

                if (obstacle.position.z > Z_DELETE_LIMIT) {
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                }
            }
        }

        /**
         * Checks for collision between the car and any obstacles.
         */
        function checkCollisions() {
            const carCollisionBox = new THREE.Box3().setFromCenterAndSize(
                car.position,
                new THREE.Vector3(CAR_WIDTH, CAR_HEIGHT, CAR_DEPTH)
            );
            
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);

                if (carCollisionBox.intersectsBox(obstacleBox)) {
                    endGame();
                    break;
                }
            }
        }
        
        /**
         * Handles the Game Over state.
         */
        function endGame() {
            isGameOver = true;
            document.getElementById('final-score').textContent = Math.floor(score * 10);
            document.getElementById('game-over-overlay').style.display = 'grid';
            clock.stop();
        }
        
        /**
         * Restarts the game.
         */
        function restartGame() {
            init();
            animate(); 
        }

        /**
         * Handles the window resize event.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Handles key down events for steering and speed.
         */
        function onKeyDown(event) {
            const key = event.key;
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
                event.preventDefault(); 
            }
        }

        /**
         * Handles key up events for steering and speed.
         */
        function onKeyUp(event) {
            const key = event.key;
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
        }
        
        /**
         * Updates the car's horizontal position and rotation based on key input.
         */
        function updateCarSteering(delta) {
            horizontalVelocity = 0;
            if (keys['A'] || keys['ArrowLeft']) {
                horizontalVelocity = -1;
            } else if (keys['D'] || keys['ArrowRight']) {
                horizontalVelocity = 1;
            }

            if (horizontalVelocity !== 0) {
                const steerMultiplier = 0.5 + (trackSpeed / MAX_SPEED) * 0.5; 
                car.position.x += horizontalVelocity * STEER_FACTOR * steerMultiplier * delta * 60;
                
                car.position.x = Math.max(-MAX_STEER_X, Math.min(car.position.x, MAX_STEER_X));
            }
            
            const targetTilt = horizontalVelocity * -MAX_TILT; 
            car.rotation.z += (targetTilt - car.rotation.z) * 0.1;

            camera.position.x = car.position.x;
        }

        /**
         * The main animation loop.
         */
        function animate() {
            if (isGameOver) {
                renderer.render(scene, camera);
                return; 
            }

            requestAnimationFrame(animate);

            const delta = clock.getDelta(); 

            // 1. Update Player Input/Movement
            updateCarSteering(delta);
            updateSpeed(delta); 

            // 2. Update Game State
            score += trackSpeed * delta; 
            document.getElementById('game-score').textContent = Math.floor(score * 10); 

            // 3. Dynamic Obstacle Movement 
            updateObstacleMovement();

            // 4. World Movement (Road, Buildings, etc.)
            updateWorldMovement(delta);

            // 5. Check for Collisions
            checkCollisions();

            // 6. Render the Scene
            renderer.render(scene, camera);
        }

        // Start the application
        window.onload = function () {
            init();
            animate();
        };

    </script>
</body>
</html>
